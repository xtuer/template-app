## 上传逻辑

上传逻辑:

1. 前端发送文件名、文件大小和 MD5 信息向后端查询文件上传信息。
2. 后端查询:
   * 已经在上传就返回上传状态。
   * 否则创建上传信息并返回给前端。
3. 前端根据得到的上传状态信息，上传未上传过或者上传失败的分片。
4. 后端每接收完一个分片都要更新分片上传状态，当所有分片都上传完后把所有分片按顺序合并为一个完整的文件，并标记上传完成。
5. 前端请求上传状态，查看是否上传成功。

## 上传状态

文件和分片的上传状态使用整数值表示:

```go
const (
	US_Init     int = 0 // 初始化
	US_Handling int = 1 // 上传中、合并中
	US_Failed   int = 2 // 上传失败、合并失败
	US_Success  int = 3 // 上传成功、合并成功
)
```

## 分片上传客户端

❶ 创建上传状态:

```json
{
  "fileName": "xxx.zip",
  "fileSize": 100000000,
  "fileMd5": "xxxx",
  "dstDir": "上传后的保存目录"
}
```

> 提示:
>
> * 有可能是第一次上传，也有可能是上传到一半进行断点续传，但都使用同一个接口。
> * 如果返回的 `data.state` 为 3 则表示上传成功，不需要重复上传。

❸ 上传分片:

把 state 为 0 和 2 的分片并发上传 (并发量为 5，因为浏览器也并发请求数量限制，Chrome 默认为 6):

* 根据后端返回的分片位置，从文件中读取对应段的数据进行上传，上传分片时请求参数里带上分片的 md5 (Java 随机读取文件内容可以使用内存映射)。

* 每上传完成一个分片服务器端返回分片的状态，客户端更新本地对应分片的信息:

  ```json
  { "sn": 1, "md5": "xxx", "size": 5_000_000, "startPos": 0, "endPos": 5_000_000, "state": 3 },
  ```

* 当所有分片的 state 都为 3 时，请求服务器上此文件的上传状态 (最终状态以服务器的为准):

  * 当 `data.state` 为 3 时表示上传完成，提示用户上传成功。
  * 当还有分片的 `state` 为不为 3，则继续上传 (万一上传的时候出错，需要重新上传)。

* 前端也可以增加上传某个分片的次数，失败次数多后进行提示，停止上传。

## 分片上传服务端

❷ 响应上传状态请求:

```json
{
    "code": 0,
    "success": true,
    "msg": "",
    "data": {
        "fileName": "arthas.zip",
        "fileSize": 13568788,
        "fileMd5": "34478e6086d391c90fcd04210b4c6796",
        "dstDir": "/Users/biao/Downloads/temp",
        "state": 0,
        "chunkSize": 5000000,
        "chunks": [
            {
                "sn": 0,
                "md5": "",
                "startPos": 0,
                "endPos": 5000000,
                "state": 0
            },
            {
                "sn": 1,
                "md5": "",
                "startPos": 5000000,
                "endPos": 10000000,
                "state": 0
            },
            {
                "sn": 2,
                "md5": "",
                "startPos": 10000000,
                "endPos": 13568788,
                "state": 0
            }
        ]
    }
}
```

> 提示:
>
> * 文件上传信息创建:
>   * 如果目标文件已经存在则不重复上传。
>   * 已经存在则直接返回 (支持断点续传)。
>   * 如果是第一次则创建。
>   * 上传状态保存到内存或者数据库中，key 为 `文件的 MD5`，value 为上传状态。
>   * 文件完整性验证使用 MD5。
> * 文件和分片上传状态:
>   * `data.state`: 文件上传状态: 0 (初始化)、1 (合并中)、2 (合并失败)、3 (合并成功)
>   * `data.chunks[i].state`: 分片上传状态: 0 (初始化)、1 (上传中)、2 (上传失败)、3 (上传成功)
> * 服务器端决定每个分片的大小 chunkSize，最后一个分片的大小可能会小于 chunkSize。
> * 分片的 md5 是上传分片的时候请求里带上给服务器的，用于服务器验证接收到的分片是否完整。
> * 合并文件时不要把整个分片的数据全读取到内存进行合并，否则可能会导致占用太多内存程序崩溃，而应该设置读取的最大 buffer。

❹ 接收分片:

* 分片的文件名为 `<sn>.tmp`，保存在可执行文件同级的 `upload-tmp/<fileMd5>` 目录中，分片上传完成时使用分片的 md5 验证分片是否完整，没问题时修改其 state 值为 3。分片保存示例:

  ```
  34478e6086d391c90fcd04210b4c6796
  ├── 0.tmp
  ├── 1.tmp
  └── 2.tmp
  ```

* 当所有分片都上传完后把所有分片按顺序合并为一个完整的文件:

  * 合并时设置文件上传状态 state 为 1，因为合并过程可能会比较久，在这期间客户端可能会请求上传状态。
  * 合并完成且文件 MD5 校验通过修改上传状态的 state 值为 3，表示文件上传完成，删除上传的分片。
  * 合并完成但文件 MD5 校验不通过设置上传状态 state 为 2，表示文件上传失败。
